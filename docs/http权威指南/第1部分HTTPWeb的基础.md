# 第1章　HTTP 概述

## 1.1　HTTP——因特网的多媒体信使

​	HTTP 使用的是可靠的数据传输协议，数据在传输的过程中不会被损坏或产生混乱。不用担心其完整性，无需担心 HTTP 通信会在传输过程中被破坏、复制或产生畸变了。

## 1.2　Web 客户端和服务器

​	Web 内容都是存储在 Web 服务器上的。Web 服务器所使用的是 HTTP 协议，因此经常会被称为 HTTP 服务器。这些 HTTP 服务器存储了因特网中的数据，如果 HTTP 客户端发出请求的话，它们会提供数据。客户端向服务器发送 HTTP 请求，服务器会在 HTTP 响应中回送所请求的数据，如图 1-1 所示。HTTP 客户端和 HTTP 服务器共同构成了万维网的基本组件。

<img src="../imgs/第1部分HTTPWeb的基础/截屏2022-04-06 10.37.05-9212682.png" alt="截屏2022-04-06 10.37.05-9212682" style="zoom:50%;" />

## 1.3　资源

​	Web 服务器是 Web 资源（Web resource）的宿主。Web 资源是 Web 内容的源头。

​	Web资源有静态、动态文件。

​	因特网搜索引擎也是一种资源。

### 1.3.1　媒体类型

​	因特网上有数千种不同的数据类型，HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型（MIME type）的数据格式标签。

​	MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间由一条斜杠来分隔。 

- HTML 格式的文本文档由 text/html 类型来标记。
- 普通的 ASCII 文本文档由 text/plain 类型来标记。
- JPEG 格式的图片为 image/jpeg 类型。
- GIF 格式的图片为 image/gif 类型。
- Apple 的 QuickTime 电影为 video/quicktime 类型。
- 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。”

### 1.3.2.　URI

​	每个 Web 服务器资源都有一个名字。服务器资源名被称为统一资源标识符（Uniform Resource Identi?er，URI）。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源。

​	这是 Joe 的五金商店的 Web 服务器上一个图片资源的 URI：http://www.joes-hardware.com/specials/saw-blade.gif”

​	URI 有两种形式，分别称为 URL 和 URN。

<img src="../imgs/第1部分HTTPWeb的基础/截屏2022-04-06 10.47.30-9213264.png" alt="截屏2022-04-06 10.47.30-9213264" style="zoom:50%;" />

​	统一资源定位符（URL）是资源标识符最常见的形式。

- URL 的第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）。

- 第二部分给出了服务器的因特网地址（比如，www.joes-hardware.com）。

- 其余部分指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）。

  现在，几乎所有的 URI 都是 URL。

​	统一资源名（URN）。URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。

## 1.4　事务

​	一个 HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成。这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。

### 1.4.1　方法

​	HTTP 支持几种不同的请求命令，这些命令被称为 HTTP 方法（HTTP method）。每条 HTTP 请求报文都包含一个方法。

| 方法   | 描　　述                                         |
| ------ | :----------------------------------------------- |
| GET    | 从服务器向客户端发送命名资源                     |
| PUT    | 将来自客户端的数据存储到一个命名的服务器资源中去 |
| DELETE | 从服务器中删除命名资源                           |
| POST   | 将客户端数据发送到一个服务器网关应用程序         |
| HEAD   | 仅发送命名资源响应中的HTTP 首部                  |

### 1.4.2　状态码

​	每条 HTTP 响应报文返回时都会携带一个状态码。

| 状态码 | 描述                       |
| ------ | :-------------------------- |
| 200 | OK。文档正确返回 |
| 302 | Redirect（重定向）。到其他地方去获取资源 |
| 404 | Not Found（没找到）。无法找到这个资源 |

### 1.4.3　Web页面中可以包含多个对象

## 1.5　报文

​	HTTP 报文都是纯文本，不是二进制代码。

<img src="../imgs/第1部分HTTPWeb的基础/截屏2022-04-06 11.08.50-9214550.png" alt="截屏2022-04-06 11.08.50-9214550" style="zoom:50%;" />

​	从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）。从服务器发往客户端的报文称为响应报文（response message）。

​	**HTTP 报文包括以下三个部分:**

- 起始行

​	报文的第一行就是起始行，在请求报文中用来说明要做些什么，在响应报文中说明出现了什么情况。

- 首部字段

​	起始行后面有零个或多个首部字段。每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。首部以一个空行结束。添加一个首部字段和添加新行一样简单。

- 主体

​	空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化的，而主体则不同，主体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本。”

​	浏览器发送了一条 HTTP 请求报文。这条请求的起始行中有一个 GET 命令，且本地资源为 /tools.html。这条请求说明它使用的是 1.0 版的 HTTP 协议。请求报文没有主体，因为从服务器上 GET 一个简单的文档不需要请求数据。

​	服务器会回送一条 HTTP 响应报文。这条响应中包含了 HTTP 的版本号（HTTP/1.0）、一个成功状态码（200）、一个描述性的原因短语（OK），以及一块响应首部字段，在所有这些内容之后跟着包含了所请求文档的响应主体。Content-Length 首部说明了响应主体的长度，Content-Type 首部说明了文档的 MIME 类型。

## 1.6　连接

### 1.6.1　TCP/IP

​	HTTP 是个应用层协议。HTTP 无需操心网络通信的具体细节；它把联网的细节都交给了通用、可靠的因特网传输协议 TCP/IP。

​	TCP 提供了： 

- 无差错的数据传输；

- 按序传输（数据总是会按照发送的顺序到达）；

- 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）。

  

​	因特网自身就是基于 TCP/IP 的，TCP/IP 是全世界的计算机和网络设备常用的层次化分组交换网络协议集。TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信。

​	只要建立了 TCP 连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了。

​	用网络术语来说，HTTP 协议位于 TCP 的上层。HTTP 使用 TCP 来传输其报文数据。与之类似，TCP 则位于 IP 的上层）。

<img src="../imgs/第1部分HTTPWeb的基础/截屏2022-04-06 11.16.49-9215054.png" alt="截屏2022-04-06 11.16.49-9215054" style="zoom:50%;" />

### 1.6.2　连接、IP地址及端口号

​	在 HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接。

​	主机名（www.netscape.com）。主机名就是 IP 地址比较人性化的别称。可以通过一种称为域名服务（Domain Name Service，DNS）的机制方便地将主机名转换为 IP 地址。

​	有了 IP 地址和端口号，客户端就可以很方便地通过 TCP/IP 进行通信了。

<img src="../imgs/第1部分HTTPWeb的基础/截屏2022-04-06 11.20.22.png" alt="截屏2022-04-06 11.20.22" style="zoom:50%;" />

步骤如下：

(a) 浏览器从 URL 中解析出服务器的主机名；

(b) 浏览器将服务器的主机名转换成服务器的 IP 地址；

(c) 浏览器将端口号（如果有的话）从 URL 中解析出来；

(d) 浏览器建立一条与 Web 服务器的 TCP 连接；

(e) 浏览器向服务器发送一条 HTTP 请求报文；

(f) 服务器向浏览器回送一条 HTTP 响应报文；

(g) 关闭连接，浏览器显示文档。”

### 1.6.3　一个使用Telnet的实例

## 1.7　协议版本

## 1.8　Web 的结构组件

​	介绍了两个 Web 应用程序（Web 浏览器和 Web 服务器）是如何相互发送报文来实现基本事务处理的。在因特网上，要与很多 Web 应用程序进行交互。

- 代理
  位于客户端和服务器之间的 HTTP 中间实体。
  
  出于安全考虑，通常会将代理作为转发所有 Web 流量的可信任中间节点使用。代理还可以对请求和响应进行过滤。
  
- 缓存
 HTTP 的仓库，使常用页面的副本可以保存在离客户端更近的地方。

 Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，可以将经过代理传送的常用文档复制保存起来。

- 网关
 连接其他应用程序的特殊 Web 服务器。

 网关（gateway）是一种特殊的服务器，作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样。客户端可能并不知道自己正在与一个网关进行通信。

- 隧道
 对 HTTP 通信报文进行盲转发的特殊代理。

 隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。HTTP 隧道的一种常见用途是通过 HTTP 连接承载加密的安全套接字层（SSL， Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙了。

- Agent 代理
 发起自动 HTTP 请求的半智能 Web 客户端。

 用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止，我们只提到过一种 HTTP Agent 代理：Web 浏览器，但用户 Agent 代理还有很多其他类型。

 # 第2章　URL 与资源

## 2.1　浏览因特网资源

​	URI 是一类更通用的资源标识符，URL 实际上是它的一个子集。URI 是一个通用的概念，由两个主要的子集 URL 和 URN 构成，URL 是通过描述资源的位置来标识资源的，而 URN（本章稍后会介绍）则是通过名字来识别资源的，与它们当前所处位置无关。

​	HTTP 规范将更通用的概念 URI 作为其资源标识符，但实际上，HTTP 应用程序处理的只是 URI 的 URL 子集。

​	你想要获取 URL http://www.joes-hardware.com/seasonal/index-fall.html。那么 URL 分以下三部分。 

- URL 的第一部分（http）是 URL 方案（scheme）。方案可以告知 Web 客户端怎样访问资源。在这个例子中，URL 说明要使用 HTTP 协议。
- URL 的第二部分（www.joes-hardware.com）指的是服务器的位置。这部分告知 Web 客户端资源位于何处。
- URL 的第三部分（/seasonal/index-fall.html）是资源路径。路径说明了请求的是服务器上哪个特定的本地资源。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220406145619167.png" alt="image-20220406145619167" style="zoom:50%;" />

​	URL可以通过HTTP之外的其他协议来访问资源。它们可以指向因特网上的任意资源。

​	URL 提供了一种统一的资源命名方式。大多数 URL 都有同样的：“方案 :// 服务器位置 / 路径”结构。因此，对网络上的每个资源以及获取这些资源的每种方式来说，命名资源的方法都只有一种。

## 2.2　URL 的语法

大多数 URL 方案的 URL 语法都建立在这个由 9 部分构成的通用格式上：

````js
<scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>
````

​	几乎没有哪个 URL 中包含了所有这些组件。URL 最重要的 3 个部分是方案（scheme）、主机（host）和路径（path）。

通用URL组件

| 组件 | 描述                                                         | 默认值       |
| ---- | ------------------------------------------------------------ | ------------ |
| 方案 | 访问服务器以获取资源时要使用哪种协议                         | 无           |
| 用户 | 某些方案访问资源时需要的用户名                               | 匿名         |
| 密码 | 用户名后面可能要包含的密码，中间由冒号（:）分隔              | <E-mail地址> |
| 主机 | 资源宿主服务器的主机名或点分IP地址                           | 无           |
| 端口 | 资源宿主服务器正在监听的端口号。很多方案都有默认端口号（HTTP的默认端口号为80） | 每个方案特有 |
| 路径 | 服务器上资源的本地名，由一个斜杠（/）将其与前面的URL组件分隔开来。路径组件的语法是与服务器和方案有关的（本章稍后会讲到URL路径可以分为若干个段，每段都可以有其[…]” | 无           |
| 参数 | 某些方案会用这个组件来指定输入参数。参数为名/值对。URL中可以包含多个参数字段，它们相互之间以及与路径的其余部分之间用分号（;）分隔 | 无           |
| 查询 | 某些方案会用这个组件传递参数以激活应用程序（比如数据库、公告板、搜索引擎以及其他因特网网关）。查询组件的内容没有通用格式。用字符“?”将其与URL的其余部分分隔开来 | 无           |
| 片段 | 一小片或一部分资源的名字。引用对象时，不会将frag字段传送给服务器；这个字段是在客户端内部使用的。通过字符“#”将其与URL的其余部分分隔开来 | 无           |

### 2.2.1　方案——使用什么协议

​	方案实际上是规定如何访问指定资源的主要标识符，它会告诉负责解析 URL 的应用程序应该使用什么协议。在我们这个简单的 HTTP URL 中所使用的方案就是 http。

​	方案组件必须以一个字母符号开始，由第一个“:”符号将其与 URL 的其余部分分隔开来。方案名是大小写无关的。

### 2.2.2　主机与端口

​	要想在因特网上找到资源，应用程序要知道是哪台机器装载了资源，以及在那台机器的什么地方可以找到能对目标资源进行访问的服务器。URL 的主机和端口组件提 供了这两组信息。

​	主机组件标识了因特网上能够访问资源的宿主机器。可以用上述主机名（域名），或者 IP 地址来表示主机名。

​	端口组件标识了服务器正在监听的网络端口。对下层使用了 TCP 协议的 HTTP 来说，默认端口号为 80。

### 2.2.3　用户名和密码

### 2.2.4　路径

​	URL 的路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。比如：http://www.joes-hardware.com:80/seasonal/index-fall.html

​	这个 URL 中的路径为 /seasonal/index-fall.html，很像 UNIX 文件系统中的文件系统路径。路径是服务器定位资源时所需的信息。1可以用字符“/”将 HTTP URL 的路径组件划分成一些路径段（path segment）（还是与 UNIX 文件系统中的文件路径类似）。每个路径段都有自己的参数（param）组件。

### 2.2.5   参数

​	为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互，URL 中有一个**参数**组件。这个组件就是 URL 中的名值对列表，由字符“;”将其与 URL 的其余部分（以及各名值对）分隔开来。它们为应用程序提供了访问资源所需的所有附加信息。

​	比如：ftp://prep.ai.mit.edu/pub/gnu;type=d在这个例子中，有一个参数 type=d，参数名为 type，值为 d。”

### 2.2.6　查询字符串

​	http://www.joes-hardware.com/inventory-check.cgi?item=12731

​	这个 URL 的大部分都与我们见过的其他 URL 类似。只有问号（?）右边的内容是新出现的。这部分被称为查询（query）组件。URL 的查询组件和标识网关资源的 URL 路径组件一起被发送给网关资源。基本上可以将网关当作访问其他应用程序的访问点（第 8 章会对网关进行详细的讨论）。

​	很多网关都希望查询字符串以一系列“名 / 值”对的形式出现，名值对之间用字符“&”分隔：http://www.joes-hardware.com/inventory-check.cgi?item=12731&color=blue在这个例子中，查询组件有两个名 / 值对：item=12731 和 color=blue。

### 2.2.7　片段

​	为了引用部分资源或资源的一个片段，URL 支持使用片段（frag）组件来表示一个资源内部的片段。比如，URL 可以指向 HTML 文档中一个特定的图片或小节。

​	片段挂在 URL 的右手边，最前面有一个字符“#”。比如：http://www.joes-hardware.com/tools.html#drills

​	在这个例子中，片段 drills 引用了 Joe 的五金商店 Web 服务器上页面 /tools.html 中的一个部分。这部分的名字叫做 drills。

​	HTTP 服务器通常只处理整个对象，2 而不是对象的片段，客户端不能将片段传送给服务器（参见图 2-3）。浏览器从服务器获得了整个资源之后，会根据片段来显示你感兴趣的那部分资源。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220406152607109.png" alt="image-20220406152607109" style="zoom:50%;" />

## 2.3　URL 快捷方式

​	Web 客户端可以理解并使用几种 URL 快捷方式。相对 URL 是在某资源内部指定一个资源的便捷缩略方式。很多浏览器还支持 URL 的“自动扩展”，也就是用户输入 URL 的一个关键（可记忆的）部分，然后由浏览器将其余部分填充起来。

### 2.3.1　相对URL

​	URL 有两种方：绝对的和相对的。到目前为止，我们只见过绝对URL。绝对 URL 中包含有访问资源所需的全部信息。另一方面，相对 URL 是不完整的。要从相对 URL 中获取访问资源所需的全部信息，就必须相对于另一个，被称为其基础（base）的 URL 进行解析。

1. 基础URL

   转换处理的第一步就是找到基础 URL。基础 URL 是作为相对 URL 的参考点使用的。可以来自以下几个不同的地方。

   - 在资源中显式提供

     有些资源会显式地指定基础 URL。比如，HTML 文档中可能会包含一个定义了基础 URL 的 HTML 标记 <BASE>，通过它来转换那个 HTML 文档中的所有相对 URL。

   - 封装资源的基础 URL
   
     如果在一个没有显式指定基础 URL 的资源中发现了一个相对 URL，可以将它所属资源的 URL 作为基础（如例中所示）。
   
   - 没有基础 URL在
   
     某些情况下，没有基础 URL。这通常意味着你有一个相对 URL；但有时可能只是一个不完整或损坏了的 URL。
   
2. 解析相对引用
   
    ​	前面我们介绍了 URL 的基本组件和语法。要将相对 URL 转换为一个绝对 URL，下一步要做的就是将相对 URL 和基础 URL 划分成组件段。
    
    ​	实际上，这样只是在解析 URL，但这种做法会将其划分成一个个组件，因此通常会称作**分解**（decomposing）URL。只要将基础和相对 URL 划分成了组件。
    
    <img src="../imgs/第1部分HTTPWeb的基础/image-20220406154015783.png" alt="image-20220406154015783" style="zoom:50%;" />
### 2.3.2　自动扩展URL

​	有些浏览器会在用户提交 URL 之后，或者在用户输入的时候尝试着自动扩展 URL。

- 主机名扩展
  
	​	在主机名扩展中，只要有些小提示，浏览器通常就可以在没有帮助的情况下，将你输入的主机名扩展为完整的主机名。
  
- 历史扩展
  
	​	浏览器用来节省用户输入 URL 时间的另一种技巧是，将以前用户访问过的 URL 历史存储起来。当你输入 URL 时，它们就可以将你输入的 URL 与历史记录中 URL 的前缀进行匹配，并提供一些完整的选项供你选择。

## 2.4　各种令人头疼的字符

   ​	URL 是可**移植**的（portable）。它要统一地命名因特网上所有的资源，这也就意味着要通过各种不同的协议来传送这些资源。这些协议在传输数据时都会使用不同的机制，所以，设计 URL，使其可以通过任意因特网协议安全地传输是很重要的。
   ​	安全传输意味着 URL 的传输不能丢失信息。有些协议，比如传输电子邮件的简单邮件传输协议（Simple Mail Transfer Protocol，SMTP），所使用的传输方法就会剥去一些特定的字符。1 为了避开这些问题，URL 只能使用一些相对较小的、通用的安全字母表中的字符。1 这是由报文的 7 位二进制码编码造成的。如果源端是以 8 位或更多位编码的，就会有部分信息被剥离。
    ​	除了希望 URL 可以被所有因特网协议进行传送之外，设计者们还希望URL也**可供人类阅读**。因此，即使不可见、不可打印的字符能够穿过邮件程序，从而成为可移植的，也不能在 URL 中使用。22 不可打印字符中包括空格符（注意，RFC 2396 建议应用程序忽略空格符）。
	URL 还得是**完整的**，这就使问题变得更加复杂了。URL 的设计者们认识到有时人们可能会希望 URL 中包含除通用的安全字母表之外的二进制数据或字符。因此，需要有一种转义机制，能够将不安全的字符编码为安全字符，再进行传输。

### 2.4.1　URL字符集
### 2.4.2　编码机制

   ​	编码机制就是通过一种“转义”表示法来表示不安全字符的，这种转义表示法包含一个百分号（%），后面跟着两个表示字符 ASCII 码的 十六进制数。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220406155406315.png" alt="image-20220406155406315" style="zoom:50%;" />

### 2.4.3　字符限制

​	在 URL 中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII 可打印字符集中。还有些字符会与某些因特网网关和协议产生混“淆，因此不赞成使用。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220406155617443.png" alt="image-20220406155617443" style="zoom:50%;" />

## 2.5　方案的世界

**常见的方案格式**

| 方案       | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| http       | 超文本传输协议方案，除了没有用户名和密码之外，与通用的URL格式相符。如果省略了端口，就默认为80。<br>基本格式：http://<host>:<port>/<path>?<query>#<frag> <br>示例：http://www.joes-hardware.com/index.html     http://www.joes-hardware.com:80/index.html ” |
| https      | 方案https与方案http是一对。唯一的区别在于方案https使用了网景的SSL，SSL为HTTP连接提供了端到端的加密机制。其语法与HTTP的语法相同，默认端口为443。<br>基本格式：https://<host>:<port>/<path>?<query>#<frag><br>示例：https://www.joes-hardware.com/secure.html ” |
| Mailto     | Mailto URL指向的是E-mail地址。由于E-mail的行为与其他方案都有所不同（它并不指向任何可以直接访问的对象），所以mailto URL的格式与标准URL的格式也有所不同。因特网E-mail地址的语法记录在RFC 822中。<br>基本格式：mailto:<RFC-822-addr-spec><br>示例：“ mailto:joe@joes-hardware.com” |
| ftp        | 文件传输协议URL可以用来从FTP服务器上下载或向其上载文件，并获取FTP服务器上的目录结构内容的列表。在Web和URL出现之前FTP就已经存在了。Web应用程序将FTP作为一种数据访问方案使用。URL语法遵循下列通用格式。<br>基本格式：ftp://<user>:<password>@<host>:<port>/<path>;<params><br>示例： ftp://anonymous:joe%40joes-hardware.com@prep.ai.mit.edu:21/pub/gnu/” |
| rtsp,rtspu | “RTSP URL是可以通过实时流传输协议（Real Time Streaming Protocol）解析的音/视频媒体资源的标识符。方案rtspu中的u表示它是使用UDP协议来获取资源的。<br>基本格式：rtsp://<user>:<password>@<host>:<port>/<path>rtspu://<user>:<password>@<host>:<port>/<path> 示例： rtsp://www.joes-hardware.com:554/interview/cto_video” |
| file       | “方案file表示一台指定主机（通过本地磁盘、网络文件系统或其他一些文件共享系统）上可直接访问的文件。各字段都遵循通用格式。如果省略了主机名，就默认为正在使用URL的本地主机。<br>基本格式：file://<host>/<path>示例： file://OFFICE-FS/policies/casual-fridays.doc” |
| news       | 根据RFC 1036的定义，方案news用来访问一些特定的文章或新闻组。它有一个很独特的性质：news URL自身包含的信息不足以对资源进行定位。news URL中缺乏到何处获取资源的信息——没有提供主机名或机器名称。从用户那里获取此类信息是解释程序的工作。比如，在网景浏览器的“选项”（Options）菜单中，就可以指定自己的NNTP（news）服务器。这样，浏览器有了news URL的时候就知道应该使用哪个服务器了。<br>新闻资源可以从多台服务器中获得。它们被称为位置无关的，因为对它们的访问不依赖于任何一个源服务器。news URL中保留了字符“@”，用来区分指向新闻组的news URL和指向特定新闻文章的news URL。<br>基本格式：news:<newsgroup>news:<news-article-id>示例： news:rec.arts.startrek |
| telnet     | 方案telnet用于访问交互式业务。它表示的并不是对象自身，而是可通过telnet协议访问的交互式应用程序（资源）。<br/>基本格式：telnet://<user>:<password>@<host>:<port>/ <br/>示例： telnet://slurp:webhound@joes-hardware.com:23/” |



# 第3章　HTTP 报文

## 3.1　报文流HTTP 

​	报文是在 HTTP 应用程序之间发送的数据块。这些数据块以一些文本形式的**元信息**（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向的。

### 3.1.1　报文流入源端服务器

​	HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向。报文流入源端服务器，工作完成之后，会流回用户的 Agent 代理中

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407092435210.png" alt="image-20220407092435210" style="zoom:50%;" />

### 3.1.2　报文向下游流动

​	HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream）流动。所有报文的发送者都在接收者的上游（upstream）。在图中，对请求报文来说，代理 1 位于代理 3 的上游，但对响应报文来说，它就位于代理 3 的下游 1。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407092650490.png" alt="image-20220407092650490" style="zoom:40%;" />

## 3.2　报文的组成部分

​	HTTP 报文是简单的格式化数据块。看一下图给出的例子。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：对报文进行描述的起始行（start line）、包含属性的首部（header）块，以及可选的、包含数据的主体（body）部分。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407092840724.png" alt="image-20220407092840724" style="zoom:50%;" />

​	起始行和首部就是由行分隔的 ASCII 文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符（ASCII 码 13）和一个换行符（ASCII 码 10）。这个行终止序列可以写做 CRLF。需要指出的是，尽管 HTTP 规范中说明应该用 CRLF 来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有些老的，或不完整的 HTTP 应用程序并不总是既发送回车符，又发送换行符。

​	实体的主体或报文的主体（或者就称为主体）是一个可选的数据块。与起始行和首部不同的是，主体中可以包含文本或二进制数据，也可以为空。

​	在图的例子中，首部给出了一些与主体有关的信息。Content-Type 行说明了主体是什么——在这个例子中，就是纯文本文档。Content-Length 行说明了主体有多大，在这里就只有 19 个字节。

### 3.2.1　报文的语法

​	所有的 HTTP 报文都可以分为两类：请求报文（request message）和响应报文（response message）。请求报文会向 Web 服务器请求一个动作。响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407093306507.png" alt="image-20220407093306507" style="zoom:50%;" />

````json
这是请求报文的格式：
<method> <request-URL> <version>
<headers>
<entity-body>
这是响应报文的格式（注意，只有起始行的语法有所不同）：
<version> <status> <reason-phrase>
<headers>
<entity-body>
````

- 方法（method）

  ​	客户端希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST。

- 请求 URL（request-URL）

  ​	命名了所请求资源，或者 URL 路径组件的完整 URL。如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL 的主机 / 端口。

- 版本（version）

  ​	报文所使用的 HTTP 版本，其格式看起来是这样的：
  ````json
  HTTP/<major>.<minor>
  ````
  
  其中**主要版本号**（major）和**次要版本号**（minor）都是整数。

- 状态码（status-code）

  ​	这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）。

- 原因短语（reason-phrase）

  ​	数字状态码的可读版本，包含行终止序列之前的所有文本。

- 首部（header）

  ​	可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF。首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始。有些 HTTP 版本，比如 HTTP/1.1，要求有效的请求或响应报文中必须包含特定的首部。

- 实体的主体部分（entity-body）

  ​	实体的主体部分包含一个由任意数据组成的数据块。并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407094147169.png" alt="image-20220407094147169" style="zoom:50%;" />

​	注意，一组 HTTP 首部总是应该以一个空行（仅 CRLF）结束，甚至即使没有首部和实体的主体部分也应如此。但由于历史原因，很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的 CRLF。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个 CRLF 的报文。

### 3.2.2　起始行

​	所有的 HTTP 报文都以一个起始行作为开始。请求报文的起始行说明了要做些什么。响应报文的起始行说明发生了什么。

1. 请求行

   请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为**请求行**，包含了一个方法和一个请求 URL，这个方法描述了服务器应该执行的操作，请求 URL 描述了要对哪个资源执行这个方法。请求行中还包含 HTTP 的版本，用来告知服务器，客户端使用的是哪种 HTTP。

2. 响应行

   响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的 HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语。
   
3. 方法

   请求的起始行以方法作为开始，方法用来告知服务器要做些什么。比如，在行“GET /specials/saw-blade.gif HTTP/1.0”中，方法就是 GET。

| 方法    | 描述                                               | 是否包含主体 |
| ------- | -------------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                               | 否           |
| HEAD    | 只从服务器获取文档的首部                           | 否           |
| POST    | 向服务器发送需要处理的数据                         | 是           |
| PUT     | 将请求的主体部分存储在服务器上                     | 是           |
| TRACE   | 对可能经过代理服务器传送到服务器上去的报文进行追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行哪些方法                     | 否           |
| DELETE  | 从服务器上删除一份文档                             | 否           |

4. 状态码

   ​	方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。状态码位于响应的起始行中。

   ​	可以通过三位数字代码对不同状态码进行分类。200 到 299 之间的状态码表示成功。300 到 399 之间的代码表示资源已经被移走了。400 到 499 之间的代码表示客户端的请求出错了。500 到 599 之间的代码表示服务器出错了。

   状态码分类

   | 整体范围 | 已定义范围 | 分类       |
   | -------- | ---------- | :--------- |
   | 100~199  | 100~101    | 信息提示   |
   | 200~299  | 200~206    | 成功       |
   | 300~399  | 300~305    | 重定向     |
   | 400~499  | 400~415    | 客户端错误 |
   | 500~599  | 500~505    | 服务端错误 |

   常见状态码

   <img src="../imgs/第1部分HTTPWeb的基础/image-20220407095915600.png" alt="image-20220407095915600" style="zoom:45%;" />

5. 原因短语

	​    原因短语是响应起始行中的最后一个组件。它为状态码提供了文本形式的解释。比如，在行 HTTP/1.0 200 OK 中，OK 就是原因短语。
	
	​	原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者将其传送给用户，用以说明在请求期间发生了什么情况。

6. 版本号

	​	版本号会以 HTTP/x.y 的形式出现在请求和响应报文的起始行中。为 HTTP 应用程序提供了一种将自己所遵循的协议版本告知对方的方式。
	
	​	使用版本号的目的是为使用 HTTP 的应用程序提供一种线索，以便互相了解对方的能力和报文格式。

### 3.2.3　首部

​	HTTP 首部字段向请求和响应报文中添加了一些附加信息。本质上来说，它们只是一些名 / 值对的列表。比如，下面的首部行会向 Content-Length 首部字段赋值 19：Content-length：19

1. 首部分类

   HTTP 规范定义了几种首部字段。应用程序也可以随意发明自己所用的首部。HTTP 首部可以分为以下几类。

   - 通用首部
   
     既可以出现在请求报文中，也可以出现在响应报文中。
   
   - 请求首部
   
     提供更多有关请求的信息。
   
   - 响应首部
   
     提供更多有关响应的信息。
   
   - 实体首部
   
     描述主体的长度和内容，或者资源自身。
   
   - 扩展首部
   
     规范中没有定义的新首部。
   
   常见的首部实例
   
   <img src="../imgs/第1部分HTTPWeb的基础/image-20220407100739881.png" alt="image-20220407100739881" style="zoom:50%;" />

2. 首部延续行

   将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符（tab）。

   ````json
   HTTP/1.0 200 OK
   Content-Type: image/gif
   Content-Length: 8572
   Server: Test Server
   	Version 1.0
   ````

   在这个例子中，响应报文里包含了一个 Server 首部，其值被划分成了多个延续行。该首部的完整值为 Test Server Version 1.0。

### 3.2.4　实体的主体部分

​	HTTP 报文的第三部分是可选的实体主体部分。实体的主体是 HTTP 报文的负荷。就是 HTTP 要传输的内容。HTTP 报文可以承载很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等。

### 3.2.5　版本0.9的报文

​	HTTP/0.9 报文也由请求和响应组成，但请求中只包含方法和请求 URL，响应中只包含实体。它没有版本信息（它是第一个，而且是当时唯一的版本），没有状态码或原因短语，也没有首部。

## 3.3　方法

### 3.3.1　安全方法

​	HTTP 定义了一组被称为安全方法的方法。GET 方法和 HEAD 方法都被认为是安全的，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求都不会产生什么动作。

### 3.3.2　GET

​	GET 是最常用的方法。通常用于请求服务器发送某个资源。

### 3.3.3　HEAD

​	HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查。

### 3.3.4　PUT

​	与 GET 从服务器读取文档相反，PUT 方法会向服务器写入文档。有些发布系统允许用户创建 Web 页面，并用 PUT 直接将其安装到 Web 服务器上去

​	PUT 方法的语义就是让服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它。因为 PUT 允许用户对内容进行修改，所以很多 Web 服务器都要求在执行 PUT 之前，用密码登录。

### 3.3.5　POST

​	POST 方法起初是用来向服务器输入数据的 1。实际上，通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）。

**POST 用于向服务器发送数据。PUT 用于向服务器上的资源（例如文件）中存储数据。**

### 3.3.6　TRACE

​	客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。

​	TRACE 请求会在目的服务器端发起一个“环回”诊断。行程最后一站的服务器会弹回一条 TRACE 响应，并在响应主体中携带它收到的原始请求报文。这样客户端就可以查看在所有中间 HTTP 应用程序组成的请求 / 响应链上，原始报文是否，以及如何被毁坏或修改过。

### 3.3.7　OPTIONS

​	OPTIONS 方法请求 Web 服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。（有些服务器可能只支持对一些特殊类型的对象使用特定的操作）

### 3.3.8　DELETE

​	顾名思义，DELETE 方法所做的事情就是请服务器删除请求 URL 所指定的资源。但是，客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求。

### 3.3.9　扩展方法

​	HTTP 被设计成字段可扩展的，这样新的特性就不会使老的软件失效了。扩展方法指的就是没有在 HTTP/1.1 规范中定义的方法。服务器会为它所管理的资源实现一些 HTTP 服务，这些方法为开发者提供了一种扩展这些 HTTP 服务能力的手段。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407102333448.png" alt="image-20220407102333448" style="zoom:50%;" />

## 3.4　状态码

### 3.4.1　100～199——信息性状态码

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407102802473.png" alt="image-20220407102802473" style="zoom:50%;" />

### 3.4.2　200～299——成功状态码

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407103022390.png" alt="image-20220407103022390" style="zoom:50%;" />

### 3.4.3　300～399——重定向状态码

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407103150687.png" alt="image-20220407103150687" style="zoom:50%;" />

### 3.4.4　400～499——客户端错误状态码

### 3.4.5　500～599——服务器错误状态码



# 第4章　连接管理

## 4.1　TCP 连接

​	世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层协议集。客户端应用程序可以打开一条 TCP/IP 连接，连接到可能运行在世界任何地方的服务器应用程序。一旦连接建立起来了，在客户端和服务器的计算机之间交换的报文就永远不会丢失、受损或失序。

​	尽管报文不会丢失或受损，但如果计算机或网络崩溃了，客户端和服务器之间的通信仍然会被断开。在这种情况下，会通知客户端和服务器通信中断了。

​	比如，你想获取 Joe 的五金商店最新的电动工具价目表：http://www.joes-hardware.com:80/power-tools.html

​	浏览器收到这个 URL 时，会执行图 4-1 所示的步骤。第 (1) ～ (3) 步会将服务器的 IP 地址和端口号从 UL 中分离出来。在第 (4) 步中建立到 Web 服务器的 TCP 连接，并在第 (5) 步通过这条连接发送一条请求报文。在第 (6) 步读取响应，并在第 (7) 步关闭连接。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407110937536.png" alt="image-20220407110937536" style="zoom:50%;" />

### 4.1.1　TCP的可靠数据管道

​	HTTP实际上就是TCP连接及其使用规则。TCP 连接是因特网上的可靠连接。

​	TCP 为 HTTP 提供了一条**可靠的比特传输管道**。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407111404144.png" alt="image-20220407111404144" style="zoom:33%;" />

### 4.1.2　TCP流是分段的、由IP分组传送

​	TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送的。这样的话，如图 4-3a 所示，HTTP 就是“HTTP over TCP over IP”这个“协议栈”中的最顶层了。其安全版本 HTTPS 就是在 HTTP 和 TCP 之间插入了一个（称为 TLS 或 SSL 的）密码加密层

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407111521569.png" alt="image-20220407111521569" style="zoom:50%;" />

​	HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。所有这些工作都是由 TCP/IP 软件来处理的，HTTP 程序员什么都看不到。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407111614893.png" alt="image-20220407111614893" style="zoom:50%;" />

​	每个 TCP 段都是由 IP 分组承载，从一个 IP 地址发送到另一个 IP 地址的。每个 IP 分组中都包括：

- 一个 IP 分组首部（通常为 20 字节）；
- 一个 TCP 段首部（通常为 20 字节）；
- 一个 TCP 数据块（0 个或多个字节）。

IP 首部包含了源和目的 IP 地址、长度和其他一些标记。TCP 段的首部包含了 TCP 端口号、TCP 控制标记，以及用于数据排序和完整性检查的一些数字值。

### 4.1.3　保持TCP连接的持续不间断地运行

​	在任意时刻计算机都可以有几条 TCP 连接处于打开状态。TCP 是通过端口号来保持所有这些连接的正确运行的。

​	IP 地址可以将你连接到正确的计算机，而端口号则可以将你连接到正确的应用程序上去。TCP 连接是通过 4 个值来识别的：

````json
< 源IP 地址、源端口号、目的IP 地址、目的端口号>
````

​	这 4 个值一起唯一地定义了一条连接。两条不同的 TCP 连接不能拥有 4 个完全相同的地址组件值（但不同连接的部分组件可以拥有相同的值）。

### 4.1.4　用TCP套接字编程

​	操作系统提供了一些操纵其 TCP 连接的工具。为了更具体地说明问题，我们来看一个 TCP 编程接口。表 显示了套接字 API 提供的一些主要接口。这个套接字 API 向 HTTP 程序员隐藏了 TCP 和 IP 的所有细节。套接字 API 最初是为 Unix 操作系统开发的，但现在几乎所有的操作系统和语言中都有其变体存在。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407144901401.png" alt="image-20220407144901401" style="zoom:50%;" />

​	套接字 API 允许用户创建 TCP 的端点数据结构，将这些端点与远程服务器的 TCP 端点进行连接，并对数据流进行读写。TCP API 隐藏了所有底层网络协议的握手细节，以及 TCP 数据流与 IP 分组之间的分段和重装细节。

​	图中的伪代码说明了可以怎样通过套接字 API 来凸显客户端和服务器在实现 HTTP 事务时所应执行的步骤。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407145039273.png" alt="image-20220407145039273" style="zoom:50%;" />

​	我们从 Web 服务器等待连接（S4）开始。客户端根据 URL 判定出 IP 地址和端口号，并建立一条到服务器的 TCP 连接（C3）。建立连接可能要花费一些时间，时间长短取决于服务器距离的远近、服务器的负载情况，以及因特网的拥挤程度。

​	一旦建立了连接，客户端就会发送 HTTP 请求（C5），服务器则会读取请求（S6）。一旦服务器获取了整条请求报文，就会对请求进行处理，执行所请求的动作（S7），并将数据写回客户端。客户端读取数据（C6），并对响应数据进行处理（C7）。

## 4.2　对 TCP 性能的考虑

​	HTTP 紧挨着 TCP，位于其上层，所以 HTTP 事务的性能在很大程度上取决于底层 TCP 通道的性能。

### 4.2.1　HTTP事务的时延

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407145532839.png" alt="image-20220407145532839" style="zoom:40%;" />

​	注意，与建立 TCP 连接，以及传输请求和响应报文的时间相比，事务处理时间可能是很短的。除非客户端或服务器超载，或正在处理复杂的动态资源，否则 HTTP 时延就是由 TCP 网络时延构成的。

​	HTTP 事务的时延有以下几种主要原因。

1. 客户端首先需要根据 URI 确定 Web 服务器的 IP 地址和端口号。如果最近没有对 URI 中的主机名进行访问，通过 DNS 解析系统将 URI 中的主机名转换成一个 IP 地址可能要花费数十秒的时间 。

2. 接下来，客户端会向服务器发送一条 TCP 连接请求，并等待服务器回送一个请求接受应答。每条新的 TCP 连接都会有连接建立时延。这个值通常最多只有一两秒钟，但如果有数百个 HTTP 事务的话，这个值会快速地叠加上去。

3. 一旦连接建立起来了，客户端就会通过新建立的 TCP 管道来发送 HTTP 请求。数据到达时，Web 服务器会从 TCP 连接中读取请求报文，并对请求进行处理。因特网传输请求报文，以及服务器处理请求报文都需要时间。

4. 然后，Web 服务器会回送 HTTP 响应，这也需要花费时间。

​	这些 TCP 网络时延的大小取决于硬件速度、网络和服务器的负载，请求和响应报文的尺寸，以及客户端和服务器之间的距离。TCP 协议的技术复杂性也会对时延产生巨大的影响。

### 4.2.2　性能聚焦区域

​	最常见的 TCP 相关时延，其中包括： 

- TCP 连接建立握手；

- TCP 慢启动拥塞控制；

- 数据聚集的 Nagle 算法；

- 用于捎带确认的 TCP 延迟确认算法；

- TIME_WAIT 时延和端口耗尽。

### 4.2.3　TCP连接的握手时延

​	建立一条新的 TCP 连接时，甚至是在发送任意数据之前，TCP 软件之间会交换一系列的 IP 分组，对连接的有关参数进行沟通。如果连接只用来传送少量数据，这些交换过程就会严重降低 HTTP 的性能。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220407150520200.png" alt="image-20220407150520200" style="zoom:50%;" />

​	TCP 连接握手需要经过以下几个步骤。 

1. 请求新的 TCP 连接时，客户端要向服务器发送一个小的 TCP 分组（通常是 40 ～ 60 个字节）。这个分组中设置了一个特殊的 SYN 标记，说明这是一个连接请求。

2. 如果服务器接受了连接，就会对一些连接参数进行计算，并向客户端回送一个 TCP 分组，这个分组中的 SYN 和 ACK 标记都被置位，说明连接请求已被接受

3. 最后，客户端向服务器回送一条确认信息，通知它连接已成功建立（参见图 4-8c）。现代的 TCP 栈都允许客户端在这个确认分组中发送数据。

   

​	通常 HTTP 事务都不会交换太多数据，此时，SYN/SYN+ACK 握手（参见图 4-8a 和图 4-8b）会产生一个可测量的时延。TCP 连接的 ACK 分组（参见图 4-8c）通常都足够大，可以承载整个 HTTP 请求报文 2，而且很多 HTTP 服务器响应报文都可 以放入一个 IP 分组中去（比如，响应是包含了装饰性图片的小型 HTML 文件，或者是对浏览器高速缓存请求产生的 304 Not Modified 响应）。

### 4.2.4　延迟确认

​	由于因特网自身无法确保可靠的分组传输（因特网路由器超负荷的话，可以随意丢弃分组），所以 TCP 实现了自己的确认机制来确保数据的成功传输。

​	每个 TCP 段都有一个序列号和数据完整性校验和。每个段的接收者收到完好的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据。

### 4.2.5　TCP慢启动

​	TCP 数据传输的性能还取决于 TCP 连接的**使用期**（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐被称为 **TCP 慢启动**（slow start），用于防止因特网的突然过载和拥塞。

​	TCP 慢启动限制了一个 TCP 端点在任意时刻可以传输的分组数。简单来说，每成功接收一个分组，发送端就有了发送另外两个分组的权限。如果某个 HTTP 事务有大量数据要发送，是不能一次将所有分组都发送出去的。必须发送一个分组，等待确认；然后可以发送两个分组，每个分组都必须被确认，这样就可以发送四个分组了，以此类推。这种方式被称为“打开拥塞窗口”。

​	由于存在这种拥塞控制特性，所以新连接的传输速度会比已经交换过一定量数据的、“已调谐”连接慢一些。由于已调谐连接要更快一些，所以 HTTP 中有一些可以重用现存连接的工具。

### 4.2.6　Nagle算法与TCP_NODELAY

​	TCP 有一个数据流接口，应用程序可以通过它将任意尺寸的数据放入 TCP 栈中——即使一次只放一个字节也可以！但是，每个 TCP 段中都至少装载了 40 个字节的标记和首部，所以如果 TCP 发送了大量包含少量数据的分组，网络的性能就会严重下降

​	Nagle 算法（根据其发明者 John Nagle 命名）试图在发送一个分组之前，将大量 TCP 数据绑定在一起，以提高网络效率。

​	Nagle 算法会引发几种 HTTP 性能问题。首先，小的 HTTP 报文可能无法填满一个分组，可能会因为等待那些永远不会到来的额外数据而产生时延。其次，Nagle 算法与延迟确认之间的交互存在问题——Nagle 算法会阻止数据的发送，直到有确认分组抵达为止，但确认分组自身会被延迟确认算法延迟 100 ～ 200 毫秒。

### 4.2.7　TIME_WAIT累积与端口耗尽

​	当某个 TCP 端点关闭 TCP 连接时，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号。这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（称为 2MSL，通常为 2 分钟 6）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接。实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同 IP 地址和端口号的连接。

## 4.3　HTTP 连接的处理

### 4.3.2　串行事务处理时延

​	如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来

<img src="../imgs/第1部分HTTPWeb的基础/image-20220408103427980.png" alt="image-20220408103427980" style="zoom:50%;" />

现存和新兴的方法可以提高 HTTP 的连接性能。

1. 并行连接

​	通过多条 TCP 连接发起并发的 HTTP 请求。

2. 持久连接

​	重用 TCP 连接，以消除连接及关闭时延。

3. 管道化连接

​	通过共享的 TCP 连接发起并发的 HTTP 请求。

4. 复用的连接

​	交替传送请求和响应报文（实验阶段）。

## 4.4　并行连接

​	浏览器可以先完整地请求原始的 HTML 页面，然后请求第一个嵌入对象，然后请求第二个嵌入对象等，以这种简单的方式对每个嵌入式对象进行串行处理。

​	如图（页面上的每个组件都包含一个独立的 HTTP 事务）所示，HTTP 允许客户端打开多条连接，并行地执行多个 HTTP 事务。在这个例子中，并行加载了四幅嵌入式图片，每个事务都有自己的 TCP 连接。

<img src="../imgs/第1部分HTTPWeb的基础/image-20220408103639269.png" alt="image-20220408103639269" style="zoom:40%;" />



### 4.4.1　并行连接可能会提高页面的加载速度

​	包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的空载时间和带宽限制，加载速度也会有所提高。时延可以重叠起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。

### 4.4.2　并行连接不一定更快

​	即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足（比如，浏览器是通过一个 28.8kbps 的 Modem 连接到因特网上去的）时，大部分的时间可能都是用来传送数据的。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。

### 4.4.3　并行连接可能让人“感觉”更快一些

​	即使实际上它们并没有加快页面的传输速度，并行连接通常也会让用户觉得页面加载得更快了，因为多个组件对象同时出现在屏幕上时，用户能够看到加载的进展。4 如果整个屏幕上有很多动作在进行，即使实际上秒表显示整个页面的下载时间更长，人们也会认为 Web 页面加载得更快一些。

## 4.5　持久连接

​	Web 客户端经常会打开到同一个站点的连接。比如，一个 Web 页面上的大部分内嵌图片通常都来自同一个 Web 站点，而且相当一部分指向其他对象的超链通常都指向同一个站点。因此，初始化了对某服务器 HTTP 请求的应用程序很可能会在不久的将来对那台服务器发起更多的请求（比如，获取在线图片）。这种性质被称为**站点局部性**（site locality）。

​	因此，HTTP/1.1（以及 HTTP/1.0 的各种增强版本）允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。在事务处理结束之后仍然保持在打开状态的 TCP 连接被称为**持久连接**。非持久连接会在每个事务结束之后关闭。持久连接会在不同事务之间保持打开状态，直到客户端或服务器决定将其关闭为止。

​	重用已对目标服务器打开的空闲持久连接，就可以避开缓慢的连接建立阶段。而且，已经打开的连接还可以避免慢启动的拥塞适应阶段，以便更快速地进行数据的传输。

### 4.5.1　持久以及并行连接

​	并行连接可以提高复合页面的传输速度。但并行连接也有一些缺点。 

- 每个事务都会打开 / 关闭一条新的连接，会耗费时间和带宽。
- 由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低。
- 可打开的并行连接数量实际上是有限的。

​	持久连接有一些比并行连接更好的地方。持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开连接的潜在数量。但是，管理持久连接时要特别小心，不然就会累积出大量的空闲连接，耗费本地以及远程客户端和服务器上的资源。

​	持久连接与并行连接配合使用可能是最高效的方式。现在，很多 Web 应用程序都会打开少量的并行连接，其中的每一个都是持久连接。持久连接有两种类型：比较老的 HTTP/1.0+“keep-alive”连接，以及现代的 HTTP/1.1“persistent”连接。

### 4.5.2　HTTP/1.0+ keep-alive连接

​	大约从 1996 年开始，很多 HTTP/1.0 浏览器和服务器都进行了扩展，以支持一种被称为 keep-alive 连接的早期实验型持久连接。

